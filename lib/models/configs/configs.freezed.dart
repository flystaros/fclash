// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'configs.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Configs _$ConfigsFromJson(Map<String, dynamic> json) {
  return _Configs.fromJson(json);
}

/// @nodoc
mixin _$Configs {
  @JsonKey(name: 'port')
  int? get port => throw _privateConstructorUsedError;
  @JsonKey(name: 'port')
  set port(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'socks-port')
  int? get socksPort => throw _privateConstructorUsedError;
  @JsonKey(name: 'socks-port')
  set socksPort(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'redir-port')
  int? get redirPort => throw _privateConstructorUsedError;
  @JsonKey(name: 'redir-port')
  set redirPort(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'tproxy-port')
  int? get tproxyPort => throw _privateConstructorUsedError;
  @JsonKey(name: 'tproxy-port')
  set tproxyPort(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'mixed-port')
  int? get mixedPort => throw _privateConstructorUsedError;
  @JsonKey(name: 'mixed-port')
  set mixedPort(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'tun')
  Tun? get tun => throw _privateConstructorUsedError;
  @JsonKey(name: 'tun')
  set tun(Tun? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'tuic-server')
  TuicServer? get tuicServer => throw _privateConstructorUsedError;
  @JsonKey(name: 'tuic-server')
  set tuicServer(TuicServer? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'ss-config')
  String? get ssConfig => throw _privateConstructorUsedError;
  @JsonKey(name: 'ss-config')
  set ssConfig(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'vmess-config')
  String? get vmessConfig => throw _privateConstructorUsedError;
  @JsonKey(name: 'vmess-config')
  set vmessConfig(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'lan-allowed-ips')
  List<String>? get lanAllowedIps => throw _privateConstructorUsedError;
  @JsonKey(name: 'lan-allowed-ips')
  set lanAllowedIps(List<String>? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'allow-lan')
  bool? get allowLan => throw _privateConstructorUsedError;
  @JsonKey(name: 'allow-lan')
  set allowLan(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'bind-address')
  String? get bindAddress => throw _privateConstructorUsedError;
  @JsonKey(name: 'bind-address')
  set bindAddress(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'inbound-tfo')
  bool? get inboundTfo => throw _privateConstructorUsedError;
  @JsonKey(name: 'inbound-tfo')
  set inboundTfo(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'inbound-mptcp')
  bool? get inboundMptcp => throw _privateConstructorUsedError;
  @JsonKey(name: 'inbound-mptcp')
  set inboundMptcp(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'mode')
  ProxyMode? get mode => throw _privateConstructorUsedError;
  @JsonKey(name: 'mode')
  set mode(ProxyMode? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'UnifiedDelay')
  bool? get unifiedDelay => throw _privateConstructorUsedError;
  @JsonKey(name: 'UnifiedDelay')
  set unifiedDelay(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'log-level')
  String? get logLevel => throw _privateConstructorUsedError;
  @JsonKey(name: 'log-level')
  set logLevel(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'ipv6')
  bool? get ipv6 => throw _privateConstructorUsedError;
  @JsonKey(name: 'ipv6')
  set ipv6(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'interface-name')
  String? get interfaceName => throw _privateConstructorUsedError;
  @JsonKey(name: 'interface-name')
  set interfaceName(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geox-url')
  GeoxUrl? get geoxUrl => throw _privateConstructorUsedError;
  @JsonKey(name: 'geox-url')
  set geoxUrl(GeoxUrl? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geo-auto-update')
  bool? get geoAutoUpdate => throw _privateConstructorUsedError;
  @JsonKey(name: 'geo-auto-update')
  set geoAutoUpdate(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geo-update-interval')
  int? get geoUpdateInterval => throw _privateConstructorUsedError;
  @JsonKey(name: 'geo-update-interval')
  set geoUpdateInterval(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geodata-mode')
  bool? get geodataMode => throw _privateConstructorUsedError;
  @JsonKey(name: 'geodata-mode')
  set geodataMode(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geodata-loader')
  String? get geodataLoader => throw _privateConstructorUsedError;
  @JsonKey(name: 'geodata-loader')
  set geodataLoader(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geosite-matcher')
  String? get geositeMatcher => throw _privateConstructorUsedError;
  @JsonKey(name: 'geosite-matcher')
  set geositeMatcher(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'tcp-concurrent')
  bool? get tcpConcurrent => throw _privateConstructorUsedError;
  @JsonKey(name: 'tcp-concurrent')
  set tcpConcurrent(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'find-process-mode')
  String? get findProcessMode => throw _privateConstructorUsedError;
  @JsonKey(name: 'find-process-mode')
  set findProcessMode(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'sniffing')
  bool? get sniffing => throw _privateConstructorUsedError;
  @JsonKey(name: 'sniffing')
  set sniffing(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'global-client-fingerprint')
  String? get globalClientFingerprint => throw _privateConstructorUsedError;
  @JsonKey(name: 'global-client-fingerprint')
  set globalClientFingerprint(String? value) =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'global-ua')
  String? get globalUa => throw _privateConstructorUsedError;
  @JsonKey(name: 'global-ua')
  set globalUa(String? value) => throw _privateConstructorUsedError;

  /// Serializes this Configs to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ConfigsCopyWith<Configs> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConfigsCopyWith<$Res> {
  factory $ConfigsCopyWith(Configs value, $Res Function(Configs) then) =
      _$ConfigsCopyWithImpl<$Res, Configs>;
  @useResult
  $Res call(
      {@JsonKey(name: 'port') int? port,
      @JsonKey(name: 'socks-port') int? socksPort,
      @JsonKey(name: 'redir-port') int? redirPort,
      @JsonKey(name: 'tproxy-port') int? tproxyPort,
      @JsonKey(name: 'mixed-port') int? mixedPort,
      @JsonKey(name: 'tun') Tun? tun,
      @JsonKey(name: 'tuic-server') TuicServer? tuicServer,
      @JsonKey(name: 'ss-config') String? ssConfig,
      @JsonKey(name: 'vmess-config') String? vmessConfig,
      @JsonKey(name: 'lan-allowed-ips') List<String>? lanAllowedIps,
      @JsonKey(name: 'allow-lan') bool? allowLan,
      @JsonKey(name: 'bind-address') String? bindAddress,
      @JsonKey(name: 'inbound-tfo') bool? inboundTfo,
      @JsonKey(name: 'inbound-mptcp') bool? inboundMptcp,
      @JsonKey(name: 'mode') ProxyMode? mode,
      @JsonKey(name: 'UnifiedDelay') bool? unifiedDelay,
      @JsonKey(name: 'log-level') String? logLevel,
      @JsonKey(name: 'ipv6') bool? ipv6,
      @JsonKey(name: 'interface-name') String? interfaceName,
      @JsonKey(name: 'geox-url') GeoxUrl? geoxUrl,
      @JsonKey(name: 'geo-auto-update') bool? geoAutoUpdate,
      @JsonKey(name: 'geo-update-interval') int? geoUpdateInterval,
      @JsonKey(name: 'geodata-mode') bool? geodataMode,
      @JsonKey(name: 'geodata-loader') String? geodataLoader,
      @JsonKey(name: 'geosite-matcher') String? geositeMatcher,
      @JsonKey(name: 'tcp-concurrent') bool? tcpConcurrent,
      @JsonKey(name: 'find-process-mode') String? findProcessMode,
      @JsonKey(name: 'sniffing') bool? sniffing,
      @JsonKey(name: 'global-client-fingerprint')
      String? globalClientFingerprint,
      @JsonKey(name: 'global-ua') String? globalUa});

  $TunCopyWith<$Res>? get tun;
  $TuicServerCopyWith<$Res>? get tuicServer;
  $GeoxUrlCopyWith<$Res>? get geoxUrl;
}

/// @nodoc
class _$ConfigsCopyWithImpl<$Res, $Val extends Configs>
    implements $ConfigsCopyWith<$Res> {
  _$ConfigsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? port = freezed,
    Object? socksPort = freezed,
    Object? redirPort = freezed,
    Object? tproxyPort = freezed,
    Object? mixedPort = freezed,
    Object? tun = freezed,
    Object? tuicServer = freezed,
    Object? ssConfig = freezed,
    Object? vmessConfig = freezed,
    Object? lanAllowedIps = freezed,
    Object? allowLan = freezed,
    Object? bindAddress = freezed,
    Object? inboundTfo = freezed,
    Object? inboundMptcp = freezed,
    Object? mode = freezed,
    Object? unifiedDelay = freezed,
    Object? logLevel = freezed,
    Object? ipv6 = freezed,
    Object? interfaceName = freezed,
    Object? geoxUrl = freezed,
    Object? geoAutoUpdate = freezed,
    Object? geoUpdateInterval = freezed,
    Object? geodataMode = freezed,
    Object? geodataLoader = freezed,
    Object? geositeMatcher = freezed,
    Object? tcpConcurrent = freezed,
    Object? findProcessMode = freezed,
    Object? sniffing = freezed,
    Object? globalClientFingerprint = freezed,
    Object? globalUa = freezed,
  }) {
    return _then(_value.copyWith(
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
      socksPort: freezed == socksPort
          ? _value.socksPort
          : socksPort // ignore: cast_nullable_to_non_nullable
              as int?,
      redirPort: freezed == redirPort
          ? _value.redirPort
          : redirPort // ignore: cast_nullable_to_non_nullable
              as int?,
      tproxyPort: freezed == tproxyPort
          ? _value.tproxyPort
          : tproxyPort // ignore: cast_nullable_to_non_nullable
              as int?,
      mixedPort: freezed == mixedPort
          ? _value.mixedPort
          : mixedPort // ignore: cast_nullable_to_non_nullable
              as int?,
      tun: freezed == tun
          ? _value.tun
          : tun // ignore: cast_nullable_to_non_nullable
              as Tun?,
      tuicServer: freezed == tuicServer
          ? _value.tuicServer
          : tuicServer // ignore: cast_nullable_to_non_nullable
              as TuicServer?,
      ssConfig: freezed == ssConfig
          ? _value.ssConfig
          : ssConfig // ignore: cast_nullable_to_non_nullable
              as String?,
      vmessConfig: freezed == vmessConfig
          ? _value.vmessConfig
          : vmessConfig // ignore: cast_nullable_to_non_nullable
              as String?,
      lanAllowedIps: freezed == lanAllowedIps
          ? _value.lanAllowedIps
          : lanAllowedIps // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      allowLan: freezed == allowLan
          ? _value.allowLan
          : allowLan // ignore: cast_nullable_to_non_nullable
              as bool?,
      bindAddress: freezed == bindAddress
          ? _value.bindAddress
          : bindAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      inboundTfo: freezed == inboundTfo
          ? _value.inboundTfo
          : inboundTfo // ignore: cast_nullable_to_non_nullable
              as bool?,
      inboundMptcp: freezed == inboundMptcp
          ? _value.inboundMptcp
          : inboundMptcp // ignore: cast_nullable_to_non_nullable
              as bool?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as ProxyMode?,
      unifiedDelay: freezed == unifiedDelay
          ? _value.unifiedDelay
          : unifiedDelay // ignore: cast_nullable_to_non_nullable
              as bool?,
      logLevel: freezed == logLevel
          ? _value.logLevel
          : logLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      ipv6: freezed == ipv6
          ? _value.ipv6
          : ipv6 // ignore: cast_nullable_to_non_nullable
              as bool?,
      interfaceName: freezed == interfaceName
          ? _value.interfaceName
          : interfaceName // ignore: cast_nullable_to_non_nullable
              as String?,
      geoxUrl: freezed == geoxUrl
          ? _value.geoxUrl
          : geoxUrl // ignore: cast_nullable_to_non_nullable
              as GeoxUrl?,
      geoAutoUpdate: freezed == geoAutoUpdate
          ? _value.geoAutoUpdate
          : geoAutoUpdate // ignore: cast_nullable_to_non_nullable
              as bool?,
      geoUpdateInterval: freezed == geoUpdateInterval
          ? _value.geoUpdateInterval
          : geoUpdateInterval // ignore: cast_nullable_to_non_nullable
              as int?,
      geodataMode: freezed == geodataMode
          ? _value.geodataMode
          : geodataMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      geodataLoader: freezed == geodataLoader
          ? _value.geodataLoader
          : geodataLoader // ignore: cast_nullable_to_non_nullable
              as String?,
      geositeMatcher: freezed == geositeMatcher
          ? _value.geositeMatcher
          : geositeMatcher // ignore: cast_nullable_to_non_nullable
              as String?,
      tcpConcurrent: freezed == tcpConcurrent
          ? _value.tcpConcurrent
          : tcpConcurrent // ignore: cast_nullable_to_non_nullable
              as bool?,
      findProcessMode: freezed == findProcessMode
          ? _value.findProcessMode
          : findProcessMode // ignore: cast_nullable_to_non_nullable
              as String?,
      sniffing: freezed == sniffing
          ? _value.sniffing
          : sniffing // ignore: cast_nullable_to_non_nullable
              as bool?,
      globalClientFingerprint: freezed == globalClientFingerprint
          ? _value.globalClientFingerprint
          : globalClientFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      globalUa: freezed == globalUa
          ? _value.globalUa
          : globalUa // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TunCopyWith<$Res>? get tun {
    if (_value.tun == null) {
      return null;
    }

    return $TunCopyWith<$Res>(_value.tun!, (value) {
      return _then(_value.copyWith(tun: value) as $Val);
    });
  }

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TuicServerCopyWith<$Res>? get tuicServer {
    if (_value.tuicServer == null) {
      return null;
    }

    return $TuicServerCopyWith<$Res>(_value.tuicServer!, (value) {
      return _then(_value.copyWith(tuicServer: value) as $Val);
    });
  }

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GeoxUrlCopyWith<$Res>? get geoxUrl {
    if (_value.geoxUrl == null) {
      return null;
    }

    return $GeoxUrlCopyWith<$Res>(_value.geoxUrl!, (value) {
      return _then(_value.copyWith(geoxUrl: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ConfigsImplCopyWith<$Res> implements $ConfigsCopyWith<$Res> {
  factory _$$ConfigsImplCopyWith(
          _$ConfigsImpl value, $Res Function(_$ConfigsImpl) then) =
      __$$ConfigsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'port') int? port,
      @JsonKey(name: 'socks-port') int? socksPort,
      @JsonKey(name: 'redir-port') int? redirPort,
      @JsonKey(name: 'tproxy-port') int? tproxyPort,
      @JsonKey(name: 'mixed-port') int? mixedPort,
      @JsonKey(name: 'tun') Tun? tun,
      @JsonKey(name: 'tuic-server') TuicServer? tuicServer,
      @JsonKey(name: 'ss-config') String? ssConfig,
      @JsonKey(name: 'vmess-config') String? vmessConfig,
      @JsonKey(name: 'lan-allowed-ips') List<String>? lanAllowedIps,
      @JsonKey(name: 'allow-lan') bool? allowLan,
      @JsonKey(name: 'bind-address') String? bindAddress,
      @JsonKey(name: 'inbound-tfo') bool? inboundTfo,
      @JsonKey(name: 'inbound-mptcp') bool? inboundMptcp,
      @JsonKey(name: 'mode') ProxyMode? mode,
      @JsonKey(name: 'UnifiedDelay') bool? unifiedDelay,
      @JsonKey(name: 'log-level') String? logLevel,
      @JsonKey(name: 'ipv6') bool? ipv6,
      @JsonKey(name: 'interface-name') String? interfaceName,
      @JsonKey(name: 'geox-url') GeoxUrl? geoxUrl,
      @JsonKey(name: 'geo-auto-update') bool? geoAutoUpdate,
      @JsonKey(name: 'geo-update-interval') int? geoUpdateInterval,
      @JsonKey(name: 'geodata-mode') bool? geodataMode,
      @JsonKey(name: 'geodata-loader') String? geodataLoader,
      @JsonKey(name: 'geosite-matcher') String? geositeMatcher,
      @JsonKey(name: 'tcp-concurrent') bool? tcpConcurrent,
      @JsonKey(name: 'find-process-mode') String? findProcessMode,
      @JsonKey(name: 'sniffing') bool? sniffing,
      @JsonKey(name: 'global-client-fingerprint')
      String? globalClientFingerprint,
      @JsonKey(name: 'global-ua') String? globalUa});

  @override
  $TunCopyWith<$Res>? get tun;
  @override
  $TuicServerCopyWith<$Res>? get tuicServer;
  @override
  $GeoxUrlCopyWith<$Res>? get geoxUrl;
}

/// @nodoc
class __$$ConfigsImplCopyWithImpl<$Res>
    extends _$ConfigsCopyWithImpl<$Res, _$ConfigsImpl>
    implements _$$ConfigsImplCopyWith<$Res> {
  __$$ConfigsImplCopyWithImpl(
      _$ConfigsImpl _value, $Res Function(_$ConfigsImpl) _then)
      : super(_value, _then);

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? port = freezed,
    Object? socksPort = freezed,
    Object? redirPort = freezed,
    Object? tproxyPort = freezed,
    Object? mixedPort = freezed,
    Object? tun = freezed,
    Object? tuicServer = freezed,
    Object? ssConfig = freezed,
    Object? vmessConfig = freezed,
    Object? lanAllowedIps = freezed,
    Object? allowLan = freezed,
    Object? bindAddress = freezed,
    Object? inboundTfo = freezed,
    Object? inboundMptcp = freezed,
    Object? mode = freezed,
    Object? unifiedDelay = freezed,
    Object? logLevel = freezed,
    Object? ipv6 = freezed,
    Object? interfaceName = freezed,
    Object? geoxUrl = freezed,
    Object? geoAutoUpdate = freezed,
    Object? geoUpdateInterval = freezed,
    Object? geodataMode = freezed,
    Object? geodataLoader = freezed,
    Object? geositeMatcher = freezed,
    Object? tcpConcurrent = freezed,
    Object? findProcessMode = freezed,
    Object? sniffing = freezed,
    Object? globalClientFingerprint = freezed,
    Object? globalUa = freezed,
  }) {
    return _then(_$ConfigsImpl(
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
      socksPort: freezed == socksPort
          ? _value.socksPort
          : socksPort // ignore: cast_nullable_to_non_nullable
              as int?,
      redirPort: freezed == redirPort
          ? _value.redirPort
          : redirPort // ignore: cast_nullable_to_non_nullable
              as int?,
      tproxyPort: freezed == tproxyPort
          ? _value.tproxyPort
          : tproxyPort // ignore: cast_nullable_to_non_nullable
              as int?,
      mixedPort: freezed == mixedPort
          ? _value.mixedPort
          : mixedPort // ignore: cast_nullable_to_non_nullable
              as int?,
      tun: freezed == tun
          ? _value.tun
          : tun // ignore: cast_nullable_to_non_nullable
              as Tun?,
      tuicServer: freezed == tuicServer
          ? _value.tuicServer
          : tuicServer // ignore: cast_nullable_to_non_nullable
              as TuicServer?,
      ssConfig: freezed == ssConfig
          ? _value.ssConfig
          : ssConfig // ignore: cast_nullable_to_non_nullable
              as String?,
      vmessConfig: freezed == vmessConfig
          ? _value.vmessConfig
          : vmessConfig // ignore: cast_nullable_to_non_nullable
              as String?,
      lanAllowedIps: freezed == lanAllowedIps
          ? _value.lanAllowedIps
          : lanAllowedIps // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      allowLan: freezed == allowLan
          ? _value.allowLan
          : allowLan // ignore: cast_nullable_to_non_nullable
              as bool?,
      bindAddress: freezed == bindAddress
          ? _value.bindAddress
          : bindAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      inboundTfo: freezed == inboundTfo
          ? _value.inboundTfo
          : inboundTfo // ignore: cast_nullable_to_non_nullable
              as bool?,
      inboundMptcp: freezed == inboundMptcp
          ? _value.inboundMptcp
          : inboundMptcp // ignore: cast_nullable_to_non_nullable
              as bool?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as ProxyMode?,
      unifiedDelay: freezed == unifiedDelay
          ? _value.unifiedDelay
          : unifiedDelay // ignore: cast_nullable_to_non_nullable
              as bool?,
      logLevel: freezed == logLevel
          ? _value.logLevel
          : logLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      ipv6: freezed == ipv6
          ? _value.ipv6
          : ipv6 // ignore: cast_nullable_to_non_nullable
              as bool?,
      interfaceName: freezed == interfaceName
          ? _value.interfaceName
          : interfaceName // ignore: cast_nullable_to_non_nullable
              as String?,
      geoxUrl: freezed == geoxUrl
          ? _value.geoxUrl
          : geoxUrl // ignore: cast_nullable_to_non_nullable
              as GeoxUrl?,
      geoAutoUpdate: freezed == geoAutoUpdate
          ? _value.geoAutoUpdate
          : geoAutoUpdate // ignore: cast_nullable_to_non_nullable
              as bool?,
      geoUpdateInterval: freezed == geoUpdateInterval
          ? _value.geoUpdateInterval
          : geoUpdateInterval // ignore: cast_nullable_to_non_nullable
              as int?,
      geodataMode: freezed == geodataMode
          ? _value.geodataMode
          : geodataMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      geodataLoader: freezed == geodataLoader
          ? _value.geodataLoader
          : geodataLoader // ignore: cast_nullable_to_non_nullable
              as String?,
      geositeMatcher: freezed == geositeMatcher
          ? _value.geositeMatcher
          : geositeMatcher // ignore: cast_nullable_to_non_nullable
              as String?,
      tcpConcurrent: freezed == tcpConcurrent
          ? _value.tcpConcurrent
          : tcpConcurrent // ignore: cast_nullable_to_non_nullable
              as bool?,
      findProcessMode: freezed == findProcessMode
          ? _value.findProcessMode
          : findProcessMode // ignore: cast_nullable_to_non_nullable
              as String?,
      sniffing: freezed == sniffing
          ? _value.sniffing
          : sniffing // ignore: cast_nullable_to_non_nullable
              as bool?,
      globalClientFingerprint: freezed == globalClientFingerprint
          ? _value.globalClientFingerprint
          : globalClientFingerprint // ignore: cast_nullable_to_non_nullable
              as String?,
      globalUa: freezed == globalUa
          ? _value.globalUa
          : globalUa // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ConfigsImpl extends _Configs with DiagnosticableTreeMixin {
  _$ConfigsImpl(
      {@JsonKey(name: 'port') this.port,
      @JsonKey(name: 'socks-port') this.socksPort,
      @JsonKey(name: 'redir-port') this.redirPort,
      @JsonKey(name: 'tproxy-port') this.tproxyPort,
      @JsonKey(name: 'mixed-port') this.mixedPort,
      @JsonKey(name: 'tun') this.tun,
      @JsonKey(name: 'tuic-server') this.tuicServer,
      @JsonKey(name: 'ss-config') this.ssConfig,
      @JsonKey(name: 'vmess-config') this.vmessConfig,
      @JsonKey(name: 'lan-allowed-ips') this.lanAllowedIps,
      @JsonKey(name: 'allow-lan') this.allowLan,
      @JsonKey(name: 'bind-address') this.bindAddress,
      @JsonKey(name: 'inbound-tfo') this.inboundTfo,
      @JsonKey(name: 'inbound-mptcp') this.inboundMptcp,
      @JsonKey(name: 'mode') this.mode,
      @JsonKey(name: 'UnifiedDelay') this.unifiedDelay,
      @JsonKey(name: 'log-level') this.logLevel,
      @JsonKey(name: 'ipv6') this.ipv6,
      @JsonKey(name: 'interface-name') this.interfaceName,
      @JsonKey(name: 'geox-url') this.geoxUrl,
      @JsonKey(name: 'geo-auto-update') this.geoAutoUpdate,
      @JsonKey(name: 'geo-update-interval') this.geoUpdateInterval,
      @JsonKey(name: 'geodata-mode') this.geodataMode,
      @JsonKey(name: 'geodata-loader') this.geodataLoader,
      @JsonKey(name: 'geosite-matcher') this.geositeMatcher,
      @JsonKey(name: 'tcp-concurrent') this.tcpConcurrent,
      @JsonKey(name: 'find-process-mode') this.findProcessMode,
      @JsonKey(name: 'sniffing') this.sniffing,
      @JsonKey(name: 'global-client-fingerprint') this.globalClientFingerprint,
      @JsonKey(name: 'global-ua') this.globalUa})
      : super._();

  factory _$ConfigsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ConfigsImplFromJson(json);

  @override
  @JsonKey(name: 'port')
  int? port;
  @override
  @JsonKey(name: 'socks-port')
  int? socksPort;
  @override
  @JsonKey(name: 'redir-port')
  int? redirPort;
  @override
  @JsonKey(name: 'tproxy-port')
  int? tproxyPort;
  @override
  @JsonKey(name: 'mixed-port')
  int? mixedPort;
  @override
  @JsonKey(name: 'tun')
  Tun? tun;
  @override
  @JsonKey(name: 'tuic-server')
  TuicServer? tuicServer;
  @override
  @JsonKey(name: 'ss-config')
  String? ssConfig;
  @override
  @JsonKey(name: 'vmess-config')
  String? vmessConfig;
  @override
  @JsonKey(name: 'lan-allowed-ips')
  List<String>? lanAllowedIps;
  @override
  @JsonKey(name: 'allow-lan')
  bool? allowLan;
  @override
  @JsonKey(name: 'bind-address')
  String? bindAddress;
  @override
  @JsonKey(name: 'inbound-tfo')
  bool? inboundTfo;
  @override
  @JsonKey(name: 'inbound-mptcp')
  bool? inboundMptcp;
  @override
  @JsonKey(name: 'mode')
  ProxyMode? mode;
  @override
  @JsonKey(name: 'UnifiedDelay')
  bool? unifiedDelay;
  @override
  @JsonKey(name: 'log-level')
  String? logLevel;
  @override
  @JsonKey(name: 'ipv6')
  bool? ipv6;
  @override
  @JsonKey(name: 'interface-name')
  String? interfaceName;
  @override
  @JsonKey(name: 'geox-url')
  GeoxUrl? geoxUrl;
  @override
  @JsonKey(name: 'geo-auto-update')
  bool? geoAutoUpdate;
  @override
  @JsonKey(name: 'geo-update-interval')
  int? geoUpdateInterval;
  @override
  @JsonKey(name: 'geodata-mode')
  bool? geodataMode;
  @override
  @JsonKey(name: 'geodata-loader')
  String? geodataLoader;
  @override
  @JsonKey(name: 'geosite-matcher')
  String? geositeMatcher;
  @override
  @JsonKey(name: 'tcp-concurrent')
  bool? tcpConcurrent;
  @override
  @JsonKey(name: 'find-process-mode')
  String? findProcessMode;
  @override
  @JsonKey(name: 'sniffing')
  bool? sniffing;
  @override
  @JsonKey(name: 'global-client-fingerprint')
  String? globalClientFingerprint;
  @override
  @JsonKey(name: 'global-ua')
  String? globalUa;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Configs(port: $port, socksPort: $socksPort, redirPort: $redirPort, tproxyPort: $tproxyPort, mixedPort: $mixedPort, tun: $tun, tuicServer: $tuicServer, ssConfig: $ssConfig, vmessConfig: $vmessConfig, lanAllowedIps: $lanAllowedIps, allowLan: $allowLan, bindAddress: $bindAddress, inboundTfo: $inboundTfo, inboundMptcp: $inboundMptcp, mode: $mode, unifiedDelay: $unifiedDelay, logLevel: $logLevel, ipv6: $ipv6, interfaceName: $interfaceName, geoxUrl: $geoxUrl, geoAutoUpdate: $geoAutoUpdate, geoUpdateInterval: $geoUpdateInterval, geodataMode: $geodataMode, geodataLoader: $geodataLoader, geositeMatcher: $geositeMatcher, tcpConcurrent: $tcpConcurrent, findProcessMode: $findProcessMode, sniffing: $sniffing, globalClientFingerprint: $globalClientFingerprint, globalUa: $globalUa)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Configs'))
      ..add(DiagnosticsProperty('port', port))
      ..add(DiagnosticsProperty('socksPort', socksPort))
      ..add(DiagnosticsProperty('redirPort', redirPort))
      ..add(DiagnosticsProperty('tproxyPort', tproxyPort))
      ..add(DiagnosticsProperty('mixedPort', mixedPort))
      ..add(DiagnosticsProperty('tun', tun))
      ..add(DiagnosticsProperty('tuicServer', tuicServer))
      ..add(DiagnosticsProperty('ssConfig', ssConfig))
      ..add(DiagnosticsProperty('vmessConfig', vmessConfig))
      ..add(DiagnosticsProperty('lanAllowedIps', lanAllowedIps))
      ..add(DiagnosticsProperty('allowLan', allowLan))
      ..add(DiagnosticsProperty('bindAddress', bindAddress))
      ..add(DiagnosticsProperty('inboundTfo', inboundTfo))
      ..add(DiagnosticsProperty('inboundMptcp', inboundMptcp))
      ..add(DiagnosticsProperty('mode', mode))
      ..add(DiagnosticsProperty('unifiedDelay', unifiedDelay))
      ..add(DiagnosticsProperty('logLevel', logLevel))
      ..add(DiagnosticsProperty('ipv6', ipv6))
      ..add(DiagnosticsProperty('interfaceName', interfaceName))
      ..add(DiagnosticsProperty('geoxUrl', geoxUrl))
      ..add(DiagnosticsProperty('geoAutoUpdate', geoAutoUpdate))
      ..add(DiagnosticsProperty('geoUpdateInterval', geoUpdateInterval))
      ..add(DiagnosticsProperty('geodataMode', geodataMode))
      ..add(DiagnosticsProperty('geodataLoader', geodataLoader))
      ..add(DiagnosticsProperty('geositeMatcher', geositeMatcher))
      ..add(DiagnosticsProperty('tcpConcurrent', tcpConcurrent))
      ..add(DiagnosticsProperty('findProcessMode', findProcessMode))
      ..add(DiagnosticsProperty('sniffing', sniffing))
      ..add(DiagnosticsProperty(
          'globalClientFingerprint', globalClientFingerprint))
      ..add(DiagnosticsProperty('globalUa', globalUa));
  }

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfigsImplCopyWith<_$ConfigsImpl> get copyWith =>
      __$$ConfigsImplCopyWithImpl<_$ConfigsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ConfigsImplToJson(
      this,
    );
  }
}

abstract class _Configs extends Configs {
  factory _Configs(
      {@JsonKey(name: 'port') int? port,
      @JsonKey(name: 'socks-port') int? socksPort,
      @JsonKey(name: 'redir-port') int? redirPort,
      @JsonKey(name: 'tproxy-port') int? tproxyPort,
      @JsonKey(name: 'mixed-port') int? mixedPort,
      @JsonKey(name: 'tun') Tun? tun,
      @JsonKey(name: 'tuic-server') TuicServer? tuicServer,
      @JsonKey(name: 'ss-config') String? ssConfig,
      @JsonKey(name: 'vmess-config') String? vmessConfig,
      @JsonKey(name: 'lan-allowed-ips') List<String>? lanAllowedIps,
      @JsonKey(name: 'allow-lan') bool? allowLan,
      @JsonKey(name: 'bind-address') String? bindAddress,
      @JsonKey(name: 'inbound-tfo') bool? inboundTfo,
      @JsonKey(name: 'inbound-mptcp') bool? inboundMptcp,
      @JsonKey(name: 'mode') ProxyMode? mode,
      @JsonKey(name: 'UnifiedDelay') bool? unifiedDelay,
      @JsonKey(name: 'log-level') String? logLevel,
      @JsonKey(name: 'ipv6') bool? ipv6,
      @JsonKey(name: 'interface-name') String? interfaceName,
      @JsonKey(name: 'geox-url') GeoxUrl? geoxUrl,
      @JsonKey(name: 'geo-auto-update') bool? geoAutoUpdate,
      @JsonKey(name: 'geo-update-interval') int? geoUpdateInterval,
      @JsonKey(name: 'geodata-mode') bool? geodataMode,
      @JsonKey(name: 'geodata-loader') String? geodataLoader,
      @JsonKey(name: 'geosite-matcher') String? geositeMatcher,
      @JsonKey(name: 'tcp-concurrent') bool? tcpConcurrent,
      @JsonKey(name: 'find-process-mode') String? findProcessMode,
      @JsonKey(name: 'sniffing') bool? sniffing,
      @JsonKey(name: 'global-client-fingerprint')
      String? globalClientFingerprint,
      @JsonKey(name: 'global-ua') String? globalUa}) = _$ConfigsImpl;
  _Configs._() : super._();

  factory _Configs.fromJson(Map<String, dynamic> json) = _$ConfigsImpl.fromJson;

  @override
  @JsonKey(name: 'port')
  int? get port;
  @JsonKey(name: 'port')
  set port(int? value);
  @override
  @JsonKey(name: 'socks-port')
  int? get socksPort;
  @JsonKey(name: 'socks-port')
  set socksPort(int? value);
  @override
  @JsonKey(name: 'redir-port')
  int? get redirPort;
  @JsonKey(name: 'redir-port')
  set redirPort(int? value);
  @override
  @JsonKey(name: 'tproxy-port')
  int? get tproxyPort;
  @JsonKey(name: 'tproxy-port')
  set tproxyPort(int? value);
  @override
  @JsonKey(name: 'mixed-port')
  int? get mixedPort;
  @JsonKey(name: 'mixed-port')
  set mixedPort(int? value);
  @override
  @JsonKey(name: 'tun')
  Tun? get tun;
  @JsonKey(name: 'tun')
  set tun(Tun? value);
  @override
  @JsonKey(name: 'tuic-server')
  TuicServer? get tuicServer;
  @JsonKey(name: 'tuic-server')
  set tuicServer(TuicServer? value);
  @override
  @JsonKey(name: 'ss-config')
  String? get ssConfig;
  @JsonKey(name: 'ss-config')
  set ssConfig(String? value);
  @override
  @JsonKey(name: 'vmess-config')
  String? get vmessConfig;
  @JsonKey(name: 'vmess-config')
  set vmessConfig(String? value);
  @override
  @JsonKey(name: 'lan-allowed-ips')
  List<String>? get lanAllowedIps;
  @JsonKey(name: 'lan-allowed-ips')
  set lanAllowedIps(List<String>? value);
  @override
  @JsonKey(name: 'allow-lan')
  bool? get allowLan;
  @JsonKey(name: 'allow-lan')
  set allowLan(bool? value);
  @override
  @JsonKey(name: 'bind-address')
  String? get bindAddress;
  @JsonKey(name: 'bind-address')
  set bindAddress(String? value);
  @override
  @JsonKey(name: 'inbound-tfo')
  bool? get inboundTfo;
  @JsonKey(name: 'inbound-tfo')
  set inboundTfo(bool? value);
  @override
  @JsonKey(name: 'inbound-mptcp')
  bool? get inboundMptcp;
  @JsonKey(name: 'inbound-mptcp')
  set inboundMptcp(bool? value);
  @override
  @JsonKey(name: 'mode')
  ProxyMode? get mode;
  @JsonKey(name: 'mode')
  set mode(ProxyMode? value);
  @override
  @JsonKey(name: 'UnifiedDelay')
  bool? get unifiedDelay;
  @JsonKey(name: 'UnifiedDelay')
  set unifiedDelay(bool? value);
  @override
  @JsonKey(name: 'log-level')
  String? get logLevel;
  @JsonKey(name: 'log-level')
  set logLevel(String? value);
  @override
  @JsonKey(name: 'ipv6')
  bool? get ipv6;
  @JsonKey(name: 'ipv6')
  set ipv6(bool? value);
  @override
  @JsonKey(name: 'interface-name')
  String? get interfaceName;
  @JsonKey(name: 'interface-name')
  set interfaceName(String? value);
  @override
  @JsonKey(name: 'geox-url')
  GeoxUrl? get geoxUrl;
  @JsonKey(name: 'geox-url')
  set geoxUrl(GeoxUrl? value);
  @override
  @JsonKey(name: 'geo-auto-update')
  bool? get geoAutoUpdate;
  @JsonKey(name: 'geo-auto-update')
  set geoAutoUpdate(bool? value);
  @override
  @JsonKey(name: 'geo-update-interval')
  int? get geoUpdateInterval;
  @JsonKey(name: 'geo-update-interval')
  set geoUpdateInterval(int? value);
  @override
  @JsonKey(name: 'geodata-mode')
  bool? get geodataMode;
  @JsonKey(name: 'geodata-mode')
  set geodataMode(bool? value);
  @override
  @JsonKey(name: 'geodata-loader')
  String? get geodataLoader;
  @JsonKey(name: 'geodata-loader')
  set geodataLoader(String? value);
  @override
  @JsonKey(name: 'geosite-matcher')
  String? get geositeMatcher;
  @JsonKey(name: 'geosite-matcher')
  set geositeMatcher(String? value);
  @override
  @JsonKey(name: 'tcp-concurrent')
  bool? get tcpConcurrent;
  @JsonKey(name: 'tcp-concurrent')
  set tcpConcurrent(bool? value);
  @override
  @JsonKey(name: 'find-process-mode')
  String? get findProcessMode;
  @JsonKey(name: 'find-process-mode')
  set findProcessMode(String? value);
  @override
  @JsonKey(name: 'sniffing')
  bool? get sniffing;
  @JsonKey(name: 'sniffing')
  set sniffing(bool? value);
  @override
  @JsonKey(name: 'global-client-fingerprint')
  String? get globalClientFingerprint;
  @JsonKey(name: 'global-client-fingerprint')
  set globalClientFingerprint(String? value);
  @override
  @JsonKey(name: 'global-ua')
  String? get globalUa;
  @JsonKey(name: 'global-ua')
  set globalUa(String? value);

  /// Create a copy of Configs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConfigsImplCopyWith<_$ConfigsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Tun _$TunFromJson(Map<String, dynamic> json) {
  return _Tun.fromJson(json);
}

/// @nodoc
mixin _$Tun {
  @JsonKey(name: 'enable')
  bool? get enable => throw _privateConstructorUsedError;
  @JsonKey(name: 'enable')
  set enable(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'device')
  String? get device => throw _privateConstructorUsedError;
  @JsonKey(name: 'device')
  set device(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'stack')
  Stack? get stack => throw _privateConstructorUsedError;
  @JsonKey(name: 'stack')
  set stack(Stack? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'dns-hijack')
  List<String>? get dnsHijack => throw _privateConstructorUsedError;
  @JsonKey(name: 'dns-hijack')
  set dnsHijack(List<String>? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'auto-route')
  bool? get autoRoute => throw _privateConstructorUsedError;
  @JsonKey(name: 'auto-route')
  set autoRoute(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'auto-detect-interface')
  bool? get autoDetectInterface => throw _privateConstructorUsedError;
  @JsonKey(name: 'auto-detect-interface')
  set autoDetectInterface(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'gso-max-size')
  int? get gsoMaxSize => throw _privateConstructorUsedError;
  @JsonKey(name: 'gso-max-size')
  set gsoMaxSize(int? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'inet4-address')
  List<String>? get inet4Address => throw _privateConstructorUsedError;
  @JsonKey(name: 'inet4-address')
  set inet4Address(List<String>? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'file-descriptor')
  int? get fileDescriptor => throw _privateConstructorUsedError;
  @JsonKey(name: 'file-descriptor')
  set fileDescriptor(int? value) => throw _privateConstructorUsedError;

  /// Serializes this Tun to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Tun
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TunCopyWith<Tun> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TunCopyWith<$Res> {
  factory $TunCopyWith(Tun value, $Res Function(Tun) then) =
      _$TunCopyWithImpl<$Res, Tun>;
  @useResult
  $Res call(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'device') String? device,
      @JsonKey(name: 'stack') Stack? stack,
      @JsonKey(name: 'dns-hijack') List<String>? dnsHijack,
      @JsonKey(name: 'auto-route') bool? autoRoute,
      @JsonKey(name: 'auto-detect-interface') bool? autoDetectInterface,
      @JsonKey(name: 'gso-max-size') int? gsoMaxSize,
      @JsonKey(name: 'inet4-address') List<String>? inet4Address,
      @JsonKey(name: 'file-descriptor') int? fileDescriptor});
}

/// @nodoc
class _$TunCopyWithImpl<$Res, $Val extends Tun> implements $TunCopyWith<$Res> {
  _$TunCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Tun
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enable = freezed,
    Object? device = freezed,
    Object? stack = freezed,
    Object? dnsHijack = freezed,
    Object? autoRoute = freezed,
    Object? autoDetectInterface = freezed,
    Object? gsoMaxSize = freezed,
    Object? inet4Address = freezed,
    Object? fileDescriptor = freezed,
  }) {
    return _then(_value.copyWith(
      enable: freezed == enable
          ? _value.enable
          : enable // ignore: cast_nullable_to_non_nullable
              as bool?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as String?,
      stack: freezed == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as Stack?,
      dnsHijack: freezed == dnsHijack
          ? _value.dnsHijack
          : dnsHijack // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      autoRoute: freezed == autoRoute
          ? _value.autoRoute
          : autoRoute // ignore: cast_nullable_to_non_nullable
              as bool?,
      autoDetectInterface: freezed == autoDetectInterface
          ? _value.autoDetectInterface
          : autoDetectInterface // ignore: cast_nullable_to_non_nullable
              as bool?,
      gsoMaxSize: freezed == gsoMaxSize
          ? _value.gsoMaxSize
          : gsoMaxSize // ignore: cast_nullable_to_non_nullable
              as int?,
      inet4Address: freezed == inet4Address
          ? _value.inet4Address
          : inet4Address // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      fileDescriptor: freezed == fileDescriptor
          ? _value.fileDescriptor
          : fileDescriptor // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TunImplCopyWith<$Res> implements $TunCopyWith<$Res> {
  factory _$$TunImplCopyWith(_$TunImpl value, $Res Function(_$TunImpl) then) =
      __$$TunImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'device') String? device,
      @JsonKey(name: 'stack') Stack? stack,
      @JsonKey(name: 'dns-hijack') List<String>? dnsHijack,
      @JsonKey(name: 'auto-route') bool? autoRoute,
      @JsonKey(name: 'auto-detect-interface') bool? autoDetectInterface,
      @JsonKey(name: 'gso-max-size') int? gsoMaxSize,
      @JsonKey(name: 'inet4-address') List<String>? inet4Address,
      @JsonKey(name: 'file-descriptor') int? fileDescriptor});
}

/// @nodoc
class __$$TunImplCopyWithImpl<$Res> extends _$TunCopyWithImpl<$Res, _$TunImpl>
    implements _$$TunImplCopyWith<$Res> {
  __$$TunImplCopyWithImpl(_$TunImpl _value, $Res Function(_$TunImpl) _then)
      : super(_value, _then);

  /// Create a copy of Tun
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enable = freezed,
    Object? device = freezed,
    Object? stack = freezed,
    Object? dnsHijack = freezed,
    Object? autoRoute = freezed,
    Object? autoDetectInterface = freezed,
    Object? gsoMaxSize = freezed,
    Object? inet4Address = freezed,
    Object? fileDescriptor = freezed,
  }) {
    return _then(_$TunImpl(
      enable: freezed == enable
          ? _value.enable
          : enable // ignore: cast_nullable_to_non_nullable
              as bool?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as String?,
      stack: freezed == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as Stack?,
      dnsHijack: freezed == dnsHijack
          ? _value.dnsHijack
          : dnsHijack // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      autoRoute: freezed == autoRoute
          ? _value.autoRoute
          : autoRoute // ignore: cast_nullable_to_non_nullable
              as bool?,
      autoDetectInterface: freezed == autoDetectInterface
          ? _value.autoDetectInterface
          : autoDetectInterface // ignore: cast_nullable_to_non_nullable
              as bool?,
      gsoMaxSize: freezed == gsoMaxSize
          ? _value.gsoMaxSize
          : gsoMaxSize // ignore: cast_nullable_to_non_nullable
              as int?,
      inet4Address: freezed == inet4Address
          ? _value.inet4Address
          : inet4Address // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      fileDescriptor: freezed == fileDescriptor
          ? _value.fileDescriptor
          : fileDescriptor // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TunImpl with DiagnosticableTreeMixin implements _Tun {
  _$TunImpl(
      {@JsonKey(name: 'enable') this.enable,
      @JsonKey(name: 'device') this.device,
      @JsonKey(name: 'stack') this.stack,
      @JsonKey(name: 'dns-hijack') this.dnsHijack,
      @JsonKey(name: 'auto-route') this.autoRoute,
      @JsonKey(name: 'auto-detect-interface') this.autoDetectInterface,
      @JsonKey(name: 'gso-max-size') this.gsoMaxSize,
      @JsonKey(name: 'inet4-address') this.inet4Address,
      @JsonKey(name: 'file-descriptor') this.fileDescriptor});

  factory _$TunImpl.fromJson(Map<String, dynamic> json) =>
      _$$TunImplFromJson(json);

  @override
  @JsonKey(name: 'enable')
  bool? enable;
  @override
  @JsonKey(name: 'device')
  String? device;
  @override
  @JsonKey(name: 'stack')
  Stack? stack;
  @override
  @JsonKey(name: 'dns-hijack')
  List<String>? dnsHijack;
  @override
  @JsonKey(name: 'auto-route')
  bool? autoRoute;
  @override
  @JsonKey(name: 'auto-detect-interface')
  bool? autoDetectInterface;
  @override
  @JsonKey(name: 'gso-max-size')
  int? gsoMaxSize;
  @override
  @JsonKey(name: 'inet4-address')
  List<String>? inet4Address;
  @override
  @JsonKey(name: 'file-descriptor')
  int? fileDescriptor;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Tun(enable: $enable, device: $device, stack: $stack, dnsHijack: $dnsHijack, autoRoute: $autoRoute, autoDetectInterface: $autoDetectInterface, gsoMaxSize: $gsoMaxSize, inet4Address: $inet4Address, fileDescriptor: $fileDescriptor)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Tun'))
      ..add(DiagnosticsProperty('enable', enable))
      ..add(DiagnosticsProperty('device', device))
      ..add(DiagnosticsProperty('stack', stack))
      ..add(DiagnosticsProperty('dnsHijack', dnsHijack))
      ..add(DiagnosticsProperty('autoRoute', autoRoute))
      ..add(DiagnosticsProperty('autoDetectInterface', autoDetectInterface))
      ..add(DiagnosticsProperty('gsoMaxSize', gsoMaxSize))
      ..add(DiagnosticsProperty('inet4Address', inet4Address))
      ..add(DiagnosticsProperty('fileDescriptor', fileDescriptor));
  }

  /// Create a copy of Tun
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TunImplCopyWith<_$TunImpl> get copyWith =>
      __$$TunImplCopyWithImpl<_$TunImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TunImplToJson(
      this,
    );
  }
}

abstract class _Tun implements Tun {
  factory _Tun(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'device') String? device,
      @JsonKey(name: 'stack') Stack? stack,
      @JsonKey(name: 'dns-hijack') List<String>? dnsHijack,
      @JsonKey(name: 'auto-route') bool? autoRoute,
      @JsonKey(name: 'auto-detect-interface') bool? autoDetectInterface,
      @JsonKey(name: 'gso-max-size') int? gsoMaxSize,
      @JsonKey(name: 'inet4-address') List<String>? inet4Address,
      @JsonKey(name: 'file-descriptor') int? fileDescriptor}) = _$TunImpl;

  factory _Tun.fromJson(Map<String, dynamic> json) = _$TunImpl.fromJson;

  @override
  @JsonKey(name: 'enable')
  bool? get enable;
  @JsonKey(name: 'enable')
  set enable(bool? value);
  @override
  @JsonKey(name: 'device')
  String? get device;
  @JsonKey(name: 'device')
  set device(String? value);
  @override
  @JsonKey(name: 'stack')
  Stack? get stack;
  @JsonKey(name: 'stack')
  set stack(Stack? value);
  @override
  @JsonKey(name: 'dns-hijack')
  List<String>? get dnsHijack;
  @JsonKey(name: 'dns-hijack')
  set dnsHijack(List<String>? value);
  @override
  @JsonKey(name: 'auto-route')
  bool? get autoRoute;
  @JsonKey(name: 'auto-route')
  set autoRoute(bool? value);
  @override
  @JsonKey(name: 'auto-detect-interface')
  bool? get autoDetectInterface;
  @JsonKey(name: 'auto-detect-interface')
  set autoDetectInterface(bool? value);
  @override
  @JsonKey(name: 'gso-max-size')
  int? get gsoMaxSize;
  @JsonKey(name: 'gso-max-size')
  set gsoMaxSize(int? value);
  @override
  @JsonKey(name: 'inet4-address')
  List<String>? get inet4Address;
  @JsonKey(name: 'inet4-address')
  set inet4Address(List<String>? value);
  @override
  @JsonKey(name: 'file-descriptor')
  int? get fileDescriptor;
  @JsonKey(name: 'file-descriptor')
  set fileDescriptor(int? value);

  /// Create a copy of Tun
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TunImplCopyWith<_$TunImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TuicServer _$TuicServerFromJson(Map<String, dynamic> json) {
  return _TuicServer.fromJson(json);
}

/// @nodoc
mixin _$TuicServer {
  @JsonKey(name: 'enable')
  bool? get enable => throw _privateConstructorUsedError;
  @JsonKey(name: 'enable')
  set enable(bool? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'listen')
  String? get listen => throw _privateConstructorUsedError;
  @JsonKey(name: 'listen')
  set listen(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'certificate')
  String? get certificate => throw _privateConstructorUsedError;
  @JsonKey(name: 'certificate')
  set certificate(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'private-key')
  String? get privateKey => throw _privateConstructorUsedError;
  @JsonKey(name: 'private-key')
  set privateKey(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'mux-option')
  MuxOption? get muxOption => throw _privateConstructorUsedError;
  @JsonKey(name: 'mux-option')
  set muxOption(MuxOption? value) => throw _privateConstructorUsedError;

  /// Serializes this TuicServer to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TuicServerCopyWith<TuicServer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TuicServerCopyWith<$Res> {
  factory $TuicServerCopyWith(
          TuicServer value, $Res Function(TuicServer) then) =
      _$TuicServerCopyWithImpl<$Res, TuicServer>;
  @useResult
  $Res call(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'listen') String? listen,
      @JsonKey(name: 'certificate') String? certificate,
      @JsonKey(name: 'private-key') String? privateKey,
      @JsonKey(name: 'mux-option') MuxOption? muxOption});

  $MuxOptionCopyWith<$Res>? get muxOption;
}

/// @nodoc
class _$TuicServerCopyWithImpl<$Res, $Val extends TuicServer>
    implements $TuicServerCopyWith<$Res> {
  _$TuicServerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enable = freezed,
    Object? listen = freezed,
    Object? certificate = freezed,
    Object? privateKey = freezed,
    Object? muxOption = freezed,
  }) {
    return _then(_value.copyWith(
      enable: freezed == enable
          ? _value.enable
          : enable // ignore: cast_nullable_to_non_nullable
              as bool?,
      listen: freezed == listen
          ? _value.listen
          : listen // ignore: cast_nullable_to_non_nullable
              as String?,
      certificate: freezed == certificate
          ? _value.certificate
          : certificate // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String?,
      muxOption: freezed == muxOption
          ? _value.muxOption
          : muxOption // ignore: cast_nullable_to_non_nullable
              as MuxOption?,
    ) as $Val);
  }

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MuxOptionCopyWith<$Res>? get muxOption {
    if (_value.muxOption == null) {
      return null;
    }

    return $MuxOptionCopyWith<$Res>(_value.muxOption!, (value) {
      return _then(_value.copyWith(muxOption: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TuicServerImplCopyWith<$Res>
    implements $TuicServerCopyWith<$Res> {
  factory _$$TuicServerImplCopyWith(
          _$TuicServerImpl value, $Res Function(_$TuicServerImpl) then) =
      __$$TuicServerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'listen') String? listen,
      @JsonKey(name: 'certificate') String? certificate,
      @JsonKey(name: 'private-key') String? privateKey,
      @JsonKey(name: 'mux-option') MuxOption? muxOption});

  @override
  $MuxOptionCopyWith<$Res>? get muxOption;
}

/// @nodoc
class __$$TuicServerImplCopyWithImpl<$Res>
    extends _$TuicServerCopyWithImpl<$Res, _$TuicServerImpl>
    implements _$$TuicServerImplCopyWith<$Res> {
  __$$TuicServerImplCopyWithImpl(
      _$TuicServerImpl _value, $Res Function(_$TuicServerImpl) _then)
      : super(_value, _then);

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enable = freezed,
    Object? listen = freezed,
    Object? certificate = freezed,
    Object? privateKey = freezed,
    Object? muxOption = freezed,
  }) {
    return _then(_$TuicServerImpl(
      enable: freezed == enable
          ? _value.enable
          : enable // ignore: cast_nullable_to_non_nullable
              as bool?,
      listen: freezed == listen
          ? _value.listen
          : listen // ignore: cast_nullable_to_non_nullable
              as String?,
      certificate: freezed == certificate
          ? _value.certificate
          : certificate // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String?,
      muxOption: freezed == muxOption
          ? _value.muxOption
          : muxOption // ignore: cast_nullable_to_non_nullable
              as MuxOption?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TuicServerImpl with DiagnosticableTreeMixin implements _TuicServer {
  _$TuicServerImpl(
      {@JsonKey(name: 'enable') this.enable,
      @JsonKey(name: 'listen') this.listen,
      @JsonKey(name: 'certificate') this.certificate,
      @JsonKey(name: 'private-key') this.privateKey,
      @JsonKey(name: 'mux-option') this.muxOption});

  factory _$TuicServerImpl.fromJson(Map<String, dynamic> json) =>
      _$$TuicServerImplFromJson(json);

  @override
  @JsonKey(name: 'enable')
  bool? enable;
  @override
  @JsonKey(name: 'listen')
  String? listen;
  @override
  @JsonKey(name: 'certificate')
  String? certificate;
  @override
  @JsonKey(name: 'private-key')
  String? privateKey;
  @override
  @JsonKey(name: 'mux-option')
  MuxOption? muxOption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TuicServer(enable: $enable, listen: $listen, certificate: $certificate, privateKey: $privateKey, muxOption: $muxOption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TuicServer'))
      ..add(DiagnosticsProperty('enable', enable))
      ..add(DiagnosticsProperty('listen', listen))
      ..add(DiagnosticsProperty('certificate', certificate))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('muxOption', muxOption));
  }

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TuicServerImplCopyWith<_$TuicServerImpl> get copyWith =>
      __$$TuicServerImplCopyWithImpl<_$TuicServerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TuicServerImplToJson(
      this,
    );
  }
}

abstract class _TuicServer implements TuicServer {
  factory _TuicServer(
      {@JsonKey(name: 'enable') bool? enable,
      @JsonKey(name: 'listen') String? listen,
      @JsonKey(name: 'certificate') String? certificate,
      @JsonKey(name: 'private-key') String? privateKey,
      @JsonKey(name: 'mux-option') MuxOption? muxOption}) = _$TuicServerImpl;

  factory _TuicServer.fromJson(Map<String, dynamic> json) =
      _$TuicServerImpl.fromJson;

  @override
  @JsonKey(name: 'enable')
  bool? get enable;
  @JsonKey(name: 'enable')
  set enable(bool? value);
  @override
  @JsonKey(name: 'listen')
  String? get listen;
  @JsonKey(name: 'listen')
  set listen(String? value);
  @override
  @JsonKey(name: 'certificate')
  String? get certificate;
  @JsonKey(name: 'certificate')
  set certificate(String? value);
  @override
  @JsonKey(name: 'private-key')
  String? get privateKey;
  @JsonKey(name: 'private-key')
  set privateKey(String? value);
  @override
  @JsonKey(name: 'mux-option')
  MuxOption? get muxOption;
  @JsonKey(name: 'mux-option')
  set muxOption(MuxOption? value);

  /// Create a copy of TuicServer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TuicServerImplCopyWith<_$TuicServerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MuxOption _$MuxOptionFromJson(Map<String, dynamic> json) {
  return _MuxOption.fromJson(json);
}

/// @nodoc
mixin _$MuxOption {
  @JsonKey(name: 'brutal')
  Brutal? get brutal => throw _privateConstructorUsedError;
  @JsonKey(name: 'brutal')
  set brutal(Brutal? value) => throw _privateConstructorUsedError;

  /// Serializes this MuxOption to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MuxOptionCopyWith<MuxOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MuxOptionCopyWith<$Res> {
  factory $MuxOptionCopyWith(MuxOption value, $Res Function(MuxOption) then) =
      _$MuxOptionCopyWithImpl<$Res, MuxOption>;
  @useResult
  $Res call({@JsonKey(name: 'brutal') Brutal? brutal});

  $BrutalCopyWith<$Res>? get brutal;
}

/// @nodoc
class _$MuxOptionCopyWithImpl<$Res, $Val extends MuxOption>
    implements $MuxOptionCopyWith<$Res> {
  _$MuxOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? brutal = freezed,
  }) {
    return _then(_value.copyWith(
      brutal: freezed == brutal
          ? _value.brutal
          : brutal // ignore: cast_nullable_to_non_nullable
              as Brutal?,
    ) as $Val);
  }

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BrutalCopyWith<$Res>? get brutal {
    if (_value.brutal == null) {
      return null;
    }

    return $BrutalCopyWith<$Res>(_value.brutal!, (value) {
      return _then(_value.copyWith(brutal: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MuxOptionImplCopyWith<$Res>
    implements $MuxOptionCopyWith<$Res> {
  factory _$$MuxOptionImplCopyWith(
          _$MuxOptionImpl value, $Res Function(_$MuxOptionImpl) then) =
      __$$MuxOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'brutal') Brutal? brutal});

  @override
  $BrutalCopyWith<$Res>? get brutal;
}

/// @nodoc
class __$$MuxOptionImplCopyWithImpl<$Res>
    extends _$MuxOptionCopyWithImpl<$Res, _$MuxOptionImpl>
    implements _$$MuxOptionImplCopyWith<$Res> {
  __$$MuxOptionImplCopyWithImpl(
      _$MuxOptionImpl _value, $Res Function(_$MuxOptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? brutal = freezed,
  }) {
    return _then(_$MuxOptionImpl(
      brutal: freezed == brutal
          ? _value.brutal
          : brutal // ignore: cast_nullable_to_non_nullable
              as Brutal?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MuxOptionImpl with DiagnosticableTreeMixin implements _MuxOption {
  _$MuxOptionImpl({@JsonKey(name: 'brutal') this.brutal});

  factory _$MuxOptionImpl.fromJson(Map<String, dynamic> json) =>
      _$$MuxOptionImplFromJson(json);

  @override
  @JsonKey(name: 'brutal')
  Brutal? brutal;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MuxOption(brutal: $brutal)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MuxOption'))
      ..add(DiagnosticsProperty('brutal', brutal));
  }

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MuxOptionImplCopyWith<_$MuxOptionImpl> get copyWith =>
      __$$MuxOptionImplCopyWithImpl<_$MuxOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MuxOptionImplToJson(
      this,
    );
  }
}

abstract class _MuxOption implements MuxOption {
  factory _MuxOption({@JsonKey(name: 'brutal') Brutal? brutal}) =
      _$MuxOptionImpl;

  factory _MuxOption.fromJson(Map<String, dynamic> json) =
      _$MuxOptionImpl.fromJson;

  @override
  @JsonKey(name: 'brutal')
  Brutal? get brutal;
  @JsonKey(name: 'brutal')
  set brutal(Brutal? value);

  /// Create a copy of MuxOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MuxOptionImplCopyWith<_$MuxOptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Brutal _$BrutalFromJson(Map<String, dynamic> json) {
  return _Brutal.fromJson(json);
}

/// @nodoc
mixin _$Brutal {
  @JsonKey(name: 'enabled')
  bool? get enabled => throw _privateConstructorUsedError;
  @JsonKey(name: 'enabled')
  set enabled(bool? value) => throw _privateConstructorUsedError;

  /// Serializes this Brutal to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Brutal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BrutalCopyWith<Brutal> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BrutalCopyWith<$Res> {
  factory $BrutalCopyWith(Brutal value, $Res Function(Brutal) then) =
      _$BrutalCopyWithImpl<$Res, Brutal>;
  @useResult
  $Res call({@JsonKey(name: 'enabled') bool? enabled});
}

/// @nodoc
class _$BrutalCopyWithImpl<$Res, $Val extends Brutal>
    implements $BrutalCopyWith<$Res> {
  _$BrutalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Brutal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_value.copyWith(
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BrutalImplCopyWith<$Res> implements $BrutalCopyWith<$Res> {
  factory _$$BrutalImplCopyWith(
          _$BrutalImpl value, $Res Function(_$BrutalImpl) then) =
      __$$BrutalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@JsonKey(name: 'enabled') bool? enabled});
}

/// @nodoc
class __$$BrutalImplCopyWithImpl<$Res>
    extends _$BrutalCopyWithImpl<$Res, _$BrutalImpl>
    implements _$$BrutalImplCopyWith<$Res> {
  __$$BrutalImplCopyWithImpl(
      _$BrutalImpl _value, $Res Function(_$BrutalImpl) _then)
      : super(_value, _then);

  /// Create a copy of Brutal
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = freezed,
  }) {
    return _then(_$BrutalImpl(
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BrutalImpl with DiagnosticableTreeMixin implements _Brutal {
  _$BrutalImpl({@JsonKey(name: 'enabled') this.enabled});

  factory _$BrutalImpl.fromJson(Map<String, dynamic> json) =>
      _$$BrutalImplFromJson(json);

  @override
  @JsonKey(name: 'enabled')
  bool? enabled;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Brutal(enabled: $enabled)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Brutal'))
      ..add(DiagnosticsProperty('enabled', enabled));
  }

  /// Create a copy of Brutal
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BrutalImplCopyWith<_$BrutalImpl> get copyWith =>
      __$$BrutalImplCopyWithImpl<_$BrutalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BrutalImplToJson(
      this,
    );
  }
}

abstract class _Brutal implements Brutal {
  factory _Brutal({@JsonKey(name: 'enabled') bool? enabled}) = _$BrutalImpl;

  factory _Brutal.fromJson(Map<String, dynamic> json) = _$BrutalImpl.fromJson;

  @override
  @JsonKey(name: 'enabled')
  bool? get enabled;
  @JsonKey(name: 'enabled')
  set enabled(bool? value);

  /// Create a copy of Brutal
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BrutalImplCopyWith<_$BrutalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GeoxUrl _$GeoxUrlFromJson(Map<String, dynamic> json) {
  return _GeoxUrl.fromJson(json);
}

/// @nodoc
mixin _$GeoxUrl {
  @JsonKey(name: 'geoip')
  String? get geoip => throw _privateConstructorUsedError;
  @JsonKey(name: 'geoip')
  set geoip(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'mmdb')
  String? get mmdb => throw _privateConstructorUsedError;
  @JsonKey(name: 'mmdb')
  set mmdb(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'asn')
  String? get asn => throw _privateConstructorUsedError;
  @JsonKey(name: 'asn')
  set asn(String? value) => throw _privateConstructorUsedError;
  @JsonKey(name: 'geosite')
  String? get geosite => throw _privateConstructorUsedError;
  @JsonKey(name: 'geosite')
  set geosite(String? value) => throw _privateConstructorUsedError;

  /// Serializes this GeoxUrl to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GeoxUrl
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GeoxUrlCopyWith<GeoxUrl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeoxUrlCopyWith<$Res> {
  factory $GeoxUrlCopyWith(GeoxUrl value, $Res Function(GeoxUrl) then) =
      _$GeoxUrlCopyWithImpl<$Res, GeoxUrl>;
  @useResult
  $Res call(
      {@JsonKey(name: 'geoip') String? geoip,
      @JsonKey(name: 'mmdb') String? mmdb,
      @JsonKey(name: 'asn') String? asn,
      @JsonKey(name: 'geosite') String? geosite});
}

/// @nodoc
class _$GeoxUrlCopyWithImpl<$Res, $Val extends GeoxUrl>
    implements $GeoxUrlCopyWith<$Res> {
  _$GeoxUrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GeoxUrl
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? geoip = freezed,
    Object? mmdb = freezed,
    Object? asn = freezed,
    Object? geosite = freezed,
  }) {
    return _then(_value.copyWith(
      geoip: freezed == geoip
          ? _value.geoip
          : geoip // ignore: cast_nullable_to_non_nullable
              as String?,
      mmdb: freezed == mmdb
          ? _value.mmdb
          : mmdb // ignore: cast_nullable_to_non_nullable
              as String?,
      asn: freezed == asn
          ? _value.asn
          : asn // ignore: cast_nullable_to_non_nullable
              as String?,
      geosite: freezed == geosite
          ? _value.geosite
          : geosite // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GeoxUrlImplCopyWith<$Res> implements $GeoxUrlCopyWith<$Res> {
  factory _$$GeoxUrlImplCopyWith(
          _$GeoxUrlImpl value, $Res Function(_$GeoxUrlImpl) then) =
      __$$GeoxUrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'geoip') String? geoip,
      @JsonKey(name: 'mmdb') String? mmdb,
      @JsonKey(name: 'asn') String? asn,
      @JsonKey(name: 'geosite') String? geosite});
}

/// @nodoc
class __$$GeoxUrlImplCopyWithImpl<$Res>
    extends _$GeoxUrlCopyWithImpl<$Res, _$GeoxUrlImpl>
    implements _$$GeoxUrlImplCopyWith<$Res> {
  __$$GeoxUrlImplCopyWithImpl(
      _$GeoxUrlImpl _value, $Res Function(_$GeoxUrlImpl) _then)
      : super(_value, _then);

  /// Create a copy of GeoxUrl
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? geoip = freezed,
    Object? mmdb = freezed,
    Object? asn = freezed,
    Object? geosite = freezed,
  }) {
    return _then(_$GeoxUrlImpl(
      geoip: freezed == geoip
          ? _value.geoip
          : geoip // ignore: cast_nullable_to_non_nullable
              as String?,
      mmdb: freezed == mmdb
          ? _value.mmdb
          : mmdb // ignore: cast_nullable_to_non_nullable
              as String?,
      asn: freezed == asn
          ? _value.asn
          : asn // ignore: cast_nullable_to_non_nullable
              as String?,
      geosite: freezed == geosite
          ? _value.geosite
          : geosite // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GeoxUrlImpl with DiagnosticableTreeMixin implements _GeoxUrl {
  _$GeoxUrlImpl(
      {@JsonKey(name: 'geoip') this.geoip,
      @JsonKey(name: 'mmdb') this.mmdb,
      @JsonKey(name: 'asn') this.asn,
      @JsonKey(name: 'geosite') this.geosite});

  factory _$GeoxUrlImpl.fromJson(Map<String, dynamic> json) =>
      _$$GeoxUrlImplFromJson(json);

  @override
  @JsonKey(name: 'geoip')
  String? geoip;
  @override
  @JsonKey(name: 'mmdb')
  String? mmdb;
  @override
  @JsonKey(name: 'asn')
  String? asn;
  @override
  @JsonKey(name: 'geosite')
  String? geosite;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GeoxUrl(geoip: $geoip, mmdb: $mmdb, asn: $asn, geosite: $geosite)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GeoxUrl'))
      ..add(DiagnosticsProperty('geoip', geoip))
      ..add(DiagnosticsProperty('mmdb', mmdb))
      ..add(DiagnosticsProperty('asn', asn))
      ..add(DiagnosticsProperty('geosite', geosite));
  }

  /// Create a copy of GeoxUrl
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GeoxUrlImplCopyWith<_$GeoxUrlImpl> get copyWith =>
      __$$GeoxUrlImplCopyWithImpl<_$GeoxUrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GeoxUrlImplToJson(
      this,
    );
  }
}

abstract class _GeoxUrl implements GeoxUrl {
  factory _GeoxUrl(
      {@JsonKey(name: 'geoip') String? geoip,
      @JsonKey(name: 'mmdb') String? mmdb,
      @JsonKey(name: 'asn') String? asn,
      @JsonKey(name: 'geosite') String? geosite}) = _$GeoxUrlImpl;

  factory _GeoxUrl.fromJson(Map<String, dynamic> json) = _$GeoxUrlImpl.fromJson;

  @override
  @JsonKey(name: 'geoip')
  String? get geoip;
  @JsonKey(name: 'geoip')
  set geoip(String? value);
  @override
  @JsonKey(name: 'mmdb')
  String? get mmdb;
  @JsonKey(name: 'mmdb')
  set mmdb(String? value);
  @override
  @JsonKey(name: 'asn')
  String? get asn;
  @JsonKey(name: 'asn')
  set asn(String? value);
  @override
  @JsonKey(name: 'geosite')
  String? get geosite;
  @JsonKey(name: 'geosite')
  set geosite(String? value);

  /// Create a copy of GeoxUrl
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GeoxUrlImplCopyWith<_$GeoxUrlImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
